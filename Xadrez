#include <stdio.h>

/*  PROTOTIPOS (funcoes) */
void moverTorreDireitaRec(int casas);            // Torre: recursao (Direita)
void moverBispoCimaDireitaRec(int casas);        // Bispo: recursao (Cima, Direita)
void moverRainhaEsquerdaRec(int casas);          // Rainha: recursao (Esquerda)

void moverBispoLoopsAninhados(int casas);        // Bispo: loops aninhados (externo=vertical, interno=horizontal)
void moverCavaloCimaDireitaComplexo(int up, int right); // Cavalo: loops aninhados com break/continue

int main() {
    // Sem acentos, compilador com problemas ao exibir
    // Declaracao das variaveis (agrupadas por tipo)
    int casasTorre = 4, casasBispo = 5, casasRainha = 8;  // Numero de casas para cada peca (Torre ajustada p/ 4 casas conforme comentario)
    int movimentosVerticais = 2, movimentosHorizontais = 1; // Cavalo: 2 para cima, 1 para direita (L)
    int up = movimentosVerticais, right = movimentosHorizontais; // aliases explicativos

    // TORRE (recursao)
    // Movimento: 4 casas para a DIREITA
    // Estrutura utilizada: RECURSAO (substitui o for original)
    printf("Movimento da Torre (4 casas para a direita):\n");
    moverTorreDireitaRec(casasTorre);

    // BISPO (recursao)
    // Movimento: 5 casas na diagonal para CIMA e DIREITA
    // Estrutura utilizada: RECURSAO (substitui o while original)
    printf("\nMovimento do Bispo (5 casas na diagonal para cima e a direita) [recursao]:\n");
    moverBispoCimaDireitaRec(casasBispo);

    // BISPO (loops aninhados)
    // Externo = vertical (Cima), Interno = horizontal (Direita)
    printf("\nMovimento do Bispo (5 casas na diagonal para cima e a direita) [loops aninhados]:\n");
    moverBispoLoopsAninhados(casasBispo);

    // RAINHA (recursao)
    // Movimento: 8 casas para a ESQUERDA
    // Estrutura utilizada: RECURSAO (substitui o do-while original)
    printf("\nMovimento da Rainha (8 casas para a esquerda):\n");
    moverRainhaEsquerdaRec(casasRainha);

    // CAVALO (loops aninhados complexos)
    // Movimento: duas casas para CIMA e uma para a DIREITA
    // Estruturas utilizadas: FOR (externo, condicao composta) + WHILE (interno) com break/continue
    printf("\nMovimento do Cavalo (duas casas para cima e uma para a direita):\n");
    moverCavaloCimaDireitaComplexo(up, right);

    printf("\nSimulacao concluida com sucesso!\n");
    return 0;
}

// IMPLEMENTACO~ES: RECURSAO

// Torre: imprime "Direita" 'casas' vezes de forma recursiva 
void moverTorreDireitaRec(int casas) {
    if (casas <= 0) return;      // caso base
    printf("Direita\n");         // passo atual
    moverTorreDireitaRec(casas - 1); // chamada recursiva
}

// Bispo: imprime "Cima, Direita" 'casas' vezes (diagonal)
void moverBispoCimaDireitaRec(int casas) {
    if (casas <= 0) return;
    printf("Cima, Direita\n");
    moverBispoCimaDireitaRec(casas - 1);
}

// Rainha: imprime "Esquerda" 'casas' vezes
void moverRainhaEsquerdaRec(int casas) {
    if (casas <= 0) return;
    printf("Esquerda\n");
    moverRainhaEsquerdaRec(casas - 1);
}

/* BISPO: LOOPS ANINHADOS 
   Externo = vertical (simula subir 1 casa); Interno = horizontal (simula ir 1 casa para a direita).
   A combinacao por iteracao imprime "Cima, Direita". */
void moverBispoLoopsAninhados(int casas) {
    int v, h;
    for (v = 1; v <= casas; v++) {   // vertical (Cima) por 'casas' vezes
        for (h = 1; h <= 1; h++) {   // horizontal (Direita) uma vez a cada passo vertical
            printf("Cima, Direita\n");
        }
    }
}

/*  CAVALO: LOOPS ANINHADOS COMPLEXOS 
    Duas casas para CIMA (up) e uma para a DIREITA (right).
   - For com condicao composta para rodar enquanto faltar qualquer movimento.
   - While interno decide qual movimento emitir no passo atual.
   - Uso de 'break' apos emitir um movimento; 'continue' explicito para clareza. */
void moverCavaloCimaDireitaComplexo(int up, int right) {
    int movUpFeitos = 0;
    int movRightFeitos = 0;

    for ( /* init vazio */ ; (movUpFeitos < up) || (movRightFeitos < right); /* sem incremento padrao */ ) {
        while (1) {
            // Prioridade: completar primeiro as subidas (Cima)
            if (movUpFeitos < up) {
                printf("Cima\n");
                movUpFeitos++;
                break; // um movimento emitido neste passo
            }

            // Depois, mover para a Direita
            if (movRightFeitos < right) {
                // Exemplo  de controle de fluxo:
                if (right - movRightFeitos > 1) {
                    // Condicao artificial: se faltasse mais de 1 para a direita, poderiamos pular este ciclo
                    // continue; // (desativado)
                }
                printf("Direita\n");
                movRightFeitos++;
                break;
            }

            // Nada a fazer neste passo
            break;
        }

        if ((movUpFeitos >= up) && (movRightFeitos >= right)) {
            break; // finaliza o for se todos os movimentos foram feitoss
        }

        continue; // deixa claro que voltamos ao topo do for
    }
}
